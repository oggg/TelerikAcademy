## Поведенчески шаблони

### Command

Понякога е необходимо да се изпращат заявки към обекти без информация за необходимото действие, което трябва да се изпълни или дори за получвателя на заявката. Пример за това е потребителския интерфейс - съдържа обекти като бутони и менюта, които изпълняват заявка в отговор на потребителски действия. Самите бутини и менюта нямат информация за действията, които се случват при натискането/селектирането им. Команд шаблона позволява на обектите на потребителския интерфейс да генерират заявки към обекти на приложението като преобразуват самата заявка в обект. Този обект може да се запази и да се предаде като останалите обекти. 

Ключовото при този шаблон е използването на абстрактен Command клас, който дефинира интерфейс за извършване на различни операции. В най-опростената си форма този интерфейс съдържа абстрактна Execute операция. Конкретни Command подкласове дефинират получател-действие двойка като запазват получателя като инстанционна променлива и имплементирайки Execute, който да извика заявката, а получателя разполага с информация какви действия за необходими при получаването на заявката.

Сходни шаблони:
 
- Composite може да се използва за имплементиране на MacroCommands
- Memento може да запазва състоянието, което е необходимо на командата, за да върне предишното състояние. 
- Команда, която е задължително да бъде копирана преди да се добави в списъка с команди се представя като Prototype


### State (Състояние)

State позволява на обектите да променят поведението си, когато тяхното вътрешно състояние се мени. По този начин обекта сменя класа си. 
Нека има клас **TCP Connection**, който преставлява врежова свързаност. Обект от този клас може да е в някое от следните състояния: 

- Established
- Listening
- Closed

Когато обект от този клас получава заявки от други обекти той отгоравя различно в зависимост от текущото си състояние - ефекта от Open заявка зависи дали обекта е в състояние Closed или Established. Този шаблон показва как **TCP Connection** може да имплементира различно поведение в за различните си състояния. Основното при този шаблон е  
въвеждането на абстрактен клас наречен **TCP State**, който да символизира състоянията на свързаността. **TCP State** декларира общ интерфейс за всички класове, който представлява различни състояния. Подкласовете на  **TCP State** имплементират логика, специфична за съответното състояние. 

Сходни шаблони: 

- Flyweight дава информация за това кога и как State обектите могат да бъдат споделяни
- Често State обектите са от тип Singleton


### Strategy (Стратегия)

Strategy дефинира съвкупност от алгоритми, енкапсулира всеки един и ги прави взаимозаменяеми. Strategy позволява алгоритъма да се изменя независимо от клиентите, които го използват.

**Приложение:**
Съществуват множество алгоритми за разделянето на текст на редове. Вграждането на всички тези алгоритми в класовете, които ги изискват не е желателно поради няколко причини: 

- Клиентите, изискващи разделянето на редове се усложняват, ако съдържат самата имплементация за разделяне на редове. Това ги прави по-големи и по-сложни за поддръжка, особено ако съдържат няколко алгоритъма за разделяне на редовете. 
- Различните алгоритми ще са подходящи в различни ситуации. Не е необходимо да се имплементират всички алгоритми, ако не се използват до един. 
- Възникват трудности при добавянето на нови алгоритми и при промяна на съществуващите, когато разделянето на редове е неделима част от клиента. 

Всички тези проблеми могат да се избегнат с дефинирането на класове, които енкапсулират различните алгоритми. Алгоритъм, който е енкапсулиран по този начин се нарича **стратегия**. 

Обектите, създадени чрез използване на този шаблон често създават Flyweight обекти.


### Observer (Наблюдател)

Дефинира една към много зависимости между обекти по такъв начин, че когато един обект променя състоянието си, всички негови зависимости са уведомени и преработени автоматично.

**Приложения:**
Обичаен страничен ефект при разделянето на система на колекции от сходни класове е необходимостта от поддържане на съвместимостта между отделните обекти. Нежелателно е да се постига съвместимост чрез силно свързване на класовете, тъй като това намалява тяхната преизползваемост. При графичните интерфейси презентационната част се разделя от логическата - по този начин те могат да се преизползват както отделно, така и заедно. Два отделни елемента могат да визуализират информация, предоставена от логиката на приложението, използвайки различни похвати за визуализация. Тези елементи нямат информация един за друг, позволявайки използването им поотделно. При промяна на информацията, получена чрез логиката на съответното приложение, визуализиращите елементи са информирани и отразяват тази промяна.
Конкретния шаблон отразява как се установява тази зависимост. Ключовите обекти са subject (обект) и observer (наблюдател). Всеки един обект може да има различен брой наблюдатели. Всички наблюдатели са уведомени при промяна на състоянието на обекта.

Сходни шаблони:
- Медиатор
- Singleton 